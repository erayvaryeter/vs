"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.jack = exports.Jack = exports.isConfigOption = exports.isConfigType = void 0;
const node_util_1 = require("node:util");
const parse_args_js_1 = require("./parse-args.js");
// it's a tiny API, just cast it inline, it's fine
//@ts-ignore
const cliui_1 = __importDefault(require("@isaacs/cliui"));
const node_path_1 = require("node:path");
const width = Math.min((process && process.stdout && process.stdout.columns) || 80, 80);
// indentation spaces from heading level
const indent = (n) => (n - 1) * 2;
const toEnvKey = (pref, key) => {
    return [pref, key.replace(/[^a-zA-Z0-9]+/g, ' ')]
        .join(' ')
        .trim()
        .toUpperCase()
        .replace(/ /g, '_');
};
const toEnvVal = (value, delim = '\n') => {
    const str = typeof value === 'string'
        ? value
        : typeof value === 'boolean'
            ? value
                ? '1'
                : '0'
            : typeof value === 'number'
                ? String(value)
                : Array.isArray(value)
                    ? value
                        .map((v) => toEnvVal(v))
                        .join(delim)
                    : /* c8 ignore start */
                        undefined;
    if (typeof str !== 'string') {
        throw new Error(`could not serialize value to environment: ${JSON.stringify(value)}`);
    }
    /* c8 ignore stop */
    return str;
};
const fromEnvVal = (env, type, multiple, delim = '\n') => (multiple
    ? env.split(delim).map(v => fromEnvVal(v, type, false))
    : type === 'string'
        ? env
        : type === 'boolean'
            ? env === '1'
            : +env.trim());
const isConfigType = (t) => typeof t === 'string' &&
    (t === 'string' || t === 'number' || t === 'boolean');
exports.isConfigType = isConfigType;
const undefOrType = (v, t) => v === undefined || typeof v === t;
// print the value type, for error message reporting
const valueType = (v) => typeof v === 'string'
    ? 'string'
    : typeof v === 'boolean'
        ? 'boolean'
        : typeof v === 'number'
            ? 'number'
            : Array.isArray(v)
                ? joinTypes([...new Set(v.map(v => valueType(v)))]) + '[]'
                : `${v.type}${v.multiple ? '[]' : ''}`;
const joinTypes = (types) => types.length === 1 ? types[0] : `(${types.join('|')})`;
const isValidValue = (v, type, multi) => {
    if (multi) {
        if (!Array.isArray(v))
            return false;
        return !v.some((v) => !isValidValue(v, type, false));
    }
    if (Array.isArray(v))
        return false;
    return typeof v === type;
};
const isConfigOption = (o, type, multi) => !!o &&
    typeof o === 'object' &&
    (0, exports.isConfigType)(o.type) &&
    o.type === type &&
    undefOrType(o.short, 'string') &&
    undefOrType(o.description, 'string') &&
    undefOrType(o.hint, 'string') &&
    undefOrType(o.validate, 'function') &&
    (o.default === undefined || isValidValue(o.default, type, multi)) &&
    !!o.multiple === multi;
exports.isConfigOption = isConfigOption;
function num(o = {}) {
    const { default: def, validate: val, ...rest } = o;
    if (def !== undefined && !isValidValue(def, 'number', false)) {
        throw new TypeError('invalid default value');
    }
    const validate = val
        ? val
        : undefined;
    return {
        ...rest,
        default: def,
        validate,
        type: 'number',
        multiple: false,
    };
}
function numList(o = {}) {
    const { default: def, validate: val, ...rest } = o;
    if (def !== undefined && !isValidValue(def, 'number', true)) {
        throw new TypeError('invalid default value');
    }
    const validate = val
        ? val
        : undefined;
    return {
        ...rest,
        default: def,
        validate,
        type: 'number',
        multiple: true,
    };
}
function opt(o = {}) {
    const { default: def, validate: val, ...rest } = o;
    if (def !== undefined && !isValidValue(def, 'string', false)) {
        throw new TypeError('invalid default value');
    }
    const validate = val
        ? val
        : undefined;
    return {
        ...rest,
        default: def,
        validate,
        type: 'string',
        multiple: false,
    };
}
function optList(o = {}) {
    const { default: def, validate: val, ...rest } = o;
    if (def !== undefined && !isValidValue(def, 'string', true)) {
        throw new TypeError('invalid default value');
    }
    const validate = val
        ? val
        : undefined;
    return {
        ...rest,
        default: def,
        validate,
        type: 'string',
        multiple: true,
    };
}
function flag(o = {}) {
    const { hint, default: def, validate: val, ...rest } = o;
    if (def !== undefined && !isValidValue(def, 'boolean', false)) {
        throw new TypeError('invalid default value');
    }
    const validate = val
        ? val
        : undefined;
    if (hint !== undefined) {
        throw new TypeError('cannot provide hint for flag');
    }
    return {
        ...rest,
        default: def,
        validate,
        type: 'boolean',
        multiple: false,
    };
}
function flagList(o = {}) {
    const { hint, default: def, validate: val, ...rest } = o;
    if (def !== undefined && !isValidValue(def, 'boolean', true)) {
        throw new TypeError('invalid default value');
    }
    const validate = val
        ? val
        : undefined;
    if (hint !== undefined) {
        throw new TypeError('cannot provide hint for flag list');
    }
    return {
        ...rest,
        default: def,
        validate,
        type: 'boolean',
        multiple: true,
    };
}
const toParseArgsOptionsConfig = (options) => {
    const c = {};
    for (const longOption in options) {
        const config = options[longOption];
        if ((0, exports.isConfigOption)(config, 'number', true)) {
            c[longOption] = {
                type: 'string',
                multiple: true,
                default: config.default?.map(c => String(c)),
            };
        }
        else if ((0, exports.isConfigOption)(config, 'number', false)) {
            c[longOption] = {
                type: 'string',
                multiple: false,
                default: config.default === undefined
                    ? undefined
                    : String(config.default),
            };
        }
        else {
            const conf = config;
            c[longOption] = {
                type: conf.type,
                multiple: conf.multiple,
                default: conf.default,
            };
        }
        if (typeof config.short === 'string') {
            c[longOption].short = config.short;
        }
        if (config.type === 'boolean' &&
            !longOption.startsWith('no-') &&
            !options[`no-${longOption}`]) {
            c[`no-${longOption}`] = {
                type: 'boolean',
                multiple: config.multiple,
            };
        }
    }
    return c;
};
const isHeading = (r) => r.type === 'heading';
const isDescription = (r) => r.type === 'description';
/**
 * Class returned by the {@link jack} function and all configuration
 * definition methods.  This is what gets chained together.
 */
class Jack {
    #configSet;
    #shorts;
    #options;
    #fields = [];
    #env;
    #envPrefix;
    #allowPositionals;
    #usage;
    constructor(options = {}) {
        this.#options = options;
        this.#allowPositionals = options.allowPositionals !== false;
        this.#env =
            this.#options.env === undefined ? process.env : this.#options.env;
        this.#envPrefix = options.envPrefix;
        // We need to fib a little, because it's always the same object, but it
        // starts out as having an empty config set.  Then each method that adds
        // fields returns `this as Jack<C & { ...newConfigs }>`
        this.#configSet = Object.create(null);
        this.#shorts = Object.create(null);
    }
    /**
     * Set the default value (which will still be overridden by env or cli)
     * as if from a parsed config file. The optional `source` param, if
     * provided, will be included in error messages if a value is invalid or
     * unknown.
     */
    setConfigValues(values, source = '') {
        try {
            this.validate(values);
        }
        catch (er) {
            throw Object.assign(er, source ? { source } : {});
        }
        for (const [field, value] of Object.entries(values)) {
            const my = this.#configSet[field];
            my.default = value;
        }
        return this;
    }
    /**
     * Parse a string of arguments, and return the resulting
     * `{ values, positionals }` object.
     *
     * If an {@link JackOptions#envPrefix} is set, then it will read default
     * values from the environment, and write the resulting values back
     * to the environment as well.
     *
     * Environment values always take precedence over any other value, except
     * an explicit CLI setting.
     */
    parse(args = process.argv) {
        if (args === process.argv) {
            args = args.slice(process._eval !== undefined ? 1 : 2);
        }
        if (this.#envPrefix) {
            for (const [field, my] of Object.entries(this.#configSet)) {
                const ek = toEnvKey(this.#envPrefix, field);
                const env = this.#env[ek];
                if (env !== undefined) {
                    my.default = fromEnvVal(env, my.type, !!my.multiple, my.delim);
                }
            }
        }
        const options = toParseArgsOptionsConfig(this.#configSet);
        const result = (0, parse_args_js_1.parseArgs)({
            args,
            options,
            // always strict, but using our own logic
            strict: false,
            allowPositionals: this.#allowPositionals,
            tokens: true,
        });
        const p = {
            values: {},
            positionals: [],
        };
        for (const token of result.tokens) {
            if (token.kind === 'positional') {
                p.positionals.push(token.value);
                if (this.#options.stopAtPositional) {
                    p.positionals.push(...args.slice(token.index + 1));
                    return p;
                }
            }
            else if (token.kind === 'option') {
                let value = undefined;
                if (token.name.startsWith('no-')) {
                    const my = this.#configSet[token.name];
                    const pname = token.name.substring('no-'.length);
                    const pos = this.#configSet[pname];
                    if (pos &&
                        pos.type === 'boolean' &&
                        (!my ||
                            (my.type === 'boolean' && !!my.multiple === !!pos.multiple))) {
                        value = false;
                        token.name = pname;
                    }
                }
                const my = this.#configSet[token.name];
                if (!my) {
                    throw new Error(`Unknown option '${token.rawName}'. ` +
                        `To specify a positional argument starting with a '-', ` +
                        `place it at the end of the command after '--', as in ` +
                        `'-- ${token.rawName}'`);
                }
                if (value === undefined) {
                    if (token.value === undefined) {
                        if (my.type !== 'boolean') {
                            throw new Error(`No value provided for ${token.rawName}, expected ${my.type}`);
                        }
                        value = true;
                    }
                    else {
                        if (my.type === 'boolean') {
                            throw new Error(`Flag ${token.rawName} does not take a value, received '${token.value}'`);
                        }
                        if (my.type === 'string') {
                            value = token.value;
                        }
                        else {
                            value = +token.value;
                            if (value !== value) {
                                throw new Error(`Invalid value '${token.value}' provided for ` +
                                    `'${token.rawName}' option, expected number`);
                            }
                        }
                    }
                }
                if (my.multiple) {
                    const pv = p.values;
                    pv[token.name] = pv[token.name] ?? [];
                    pv[token.name].push(value);
                }
                else {
                    const pv = p.values;
                    pv[token.name] = value;
                }
            }
        }
        for (const [field, c] of Object.entries(this.#configSet)) {
            if (c.default !== undefined && !(field in p.values)) {
                //@ts-ignore
                p.values[field] = c.default;
            }
        }
        for (const [field, value] of Object.entries(p.values)) {
            const valid = this.#configSet[field].validate;
            if (valid && !valid(value)) {
                throw new Error(`Invalid value provided for --${field}: ${JSON.stringify(value)}`);
            }
        }
        this.#writeEnv(p);
        return p;
    }
    /**
     * Validate that any arbitrary object is a valid configuration `values`
     * object.  Useful when loading config files or other sources.
     */
    validate(o) {
        if (!o || typeof o !== 'object') {
            throw new Error('Invalid config: not an object');
        }
        for (const field in o) {
            const config = this.#configSet[field];
            if (!config) {
                throw new Error(`Unknown config option: ${field}`);
            }
            if (!isValidValue(o[field], config.type, !!config.multiple)) {
                throw Object.assign(new Error(`Invalid value ${valueType(o[field])} for ${field}, expected ${valueType(config)}`), {
                    field,
                    value: o[field],
                });
            }
            if (config.validate && !config.validate(o[field])) {
                throw new Error(`Invalid config value for ${field}: ${o[field]}`);
            }
        }
    }
    #writeEnv(p) {
        if (!this.#env || !this.#envPrefix)
            return;
        for (const [field, value] of Object.entries(p.values)) {
            const my = this.#configSet[field];
            this.#env[toEnvKey(this.#envPrefix, field)] = toEnvVal(value, my.delim);
        }
    }
    /**
     * Add a heading to the usage output banner
     */
    heading(text, level) {
        if (level === undefined) {
            level = this.#fields.some(r => isHeading(r)) ? 2 : 1;
        }
        this.#fields.push({ type: 'heading', text, level });
        return this;
    }
    /**
     * Add a long-form description to the usage output at this position.
     */
    description(text, { pre } = {}) {
        this.#fields.push({ type: 'description', text, pre });
        return this;
    }
    /**
     * Add one or more number fields.
     */
    num(fields) {
        return this.#addFields(fields, num);
    }
    /**
     * Add one or more multiple number fields.
     */
    numList(fields) {
        return this.#addFields(fields, numList);
    }
    /**
     * Add one or more string option fields.
     */
    opt(fields) {
        return this.#addFields(fields, opt);
    }
    /**
     * Add one or more multiple string option fields.
     */
    optList(fields) {
        return this.#addFields(fields, optList);
    }
    /**
     * Add one or more flag fields.
     */
    flag(fields) {
        return this.#addFields(fields, flag);
    }
    /**
     * Add one or more multiple flag fields.
     */
    flagList(fields) {
        return this.#addFields(fields, flagList);
    }
    /**
     * Generic field definition method. Similar to flag/flagList/number/etc,
     * but you must specify the `type` (and optionally `multiple` and `delim`)
     * fields on each one, or Jack won't know how to define them.
     */
    addFields(fields) {
        const next = this;
        for (const [name, field] of Object.entries(fields)) {
            this.#validateName(name, field);
            next.#fields.push({
                type: 'config',
                name,
                value: field,
            });
        }
        Object.assign(next.#configSet, fields);
        return next;
    }
    #addFields(fields, fn) {
        const next = this;
        Object.assign(next.#configSet, Object.fromEntries(Object.entries(fields).map(([name, field]) => {
            this.#validateName(name, field);
            const option = fn(field);
            next.#fields.push({
                type: 'config',
                name,
                value: option,
            });
            return [name, option];
        })));
        return next;
    }
    #validateName(name, field) {
        if (!/^[a-zA-Z0-9]([a-zA-Z0-9-]*[a-zA-Z0-9])?$/.test(name)) {
            throw new TypeError(`Invalid option name: ${name}, ` +
                `must be '-' delimited ASCII alphanumeric`);
        }
        if (this.#configSet[name]) {
            throw new TypeError(`Cannot redefine option ${field}`);
        }
        if (this.#shorts[name]) {
            throw new TypeError(`Cannot redefine option ${name}, already ` +
                `in use for ${this.#shorts[name]}`);
        }
        if (field.short) {
            if (!/^[a-zA-Z0-9]$/.test(field.short)) {
                throw new TypeError(`Invalid ${name} short option: ${field.short}, ` +
                    'must be 1 ASCII alphanumeric character');
            }
            if (this.#shorts[field.short]) {
                throw new TypeError(`Invalid ${name} short option: ${field.short}, ` +
                    `already in use for ${this.#shorts[field.short]}`);
            }
            this.#shorts[field.short] = name;
            this.#shorts[name] = name;
        }
    }
    /**
     * Return the usage banner for the given configuration
     */
    usage() {
        if (this.#usage)
            return this.#usage;
        let headingLevel = 1;
        const ui = (0, cliui_1.default)({ width });
        const first = this.#fields[0];
        let start = first?.type === 'heading' ? 1 : 0;
        if (first?.type === 'heading') {
            ui.div({
                padding: [0, 0, 0, 0],
                text: normalize(first.text),
            });
        }
        ui.div({ padding: [0, 0, 0, 0], text: 'Usage:' });
        if (this.#options.usage) {
            ui.div({
                text: this.#options.usage,
                padding: [0, 0, 0, 2],
            });
        }
        else {
            const cmd = (0, node_path_1.basename)(process.argv[1]);
            const shortFlags = [];
            const shorts = [];
            const flags = [];
            const opts = [];
            for (const [field, config] of Object.entries(this.#configSet)) {
                if (config.short) {
                    if (config.type === 'boolean')
                        shortFlags.push(config.short);
                    else
                        shorts.push([config.short, config.hint || field]);
                }
                else {
                    if (config.type === 'boolean')
                        flags.push(field);
                    else
                        opts.push([field, config.hint || field]);
                }
            }
            const sf = shortFlags.length ? ' -' + shortFlags.join('') : '';
            const so = shorts.map(([k, v]) => ` --${k}=<${v}>`).join('');
            const lf = flags.map(k => ` --${k}`).join('');
            const lo = opts.map(([k, v]) => ` --${k}=<${v}>`).join('');
            const usage = `${cmd}${sf}${so}${lf}${lo}`.trim();
            ui.div({
                text: usage,
                padding: [0, 0, 0, 2],
            });
        }
        ui.div({ padding: [0, 0, 0, 0], text: '' });
        const maybeDesc = this.#fields[start];
        if (isDescription(maybeDesc)) {
            const print = normalize(maybeDesc.text, maybeDesc.pre);
            start++;
            ui.div({ padding: [0, 0, 0, 0], text: print });
            ui.div({ padding: [0, 0, 0, 0], text: '' });
        }
        // turn each config type into a row, and figure out the width of the
        // left hand indentation for the option descriptions.
        let maxMax = Math.max(12, Math.min(26, Math.floor(width / 3)));
        let maxWidth = 8;
        let prev = undefined;
        const rows = [];
        for (const field of this.#fields.slice(start)) {
            if (field.type !== 'config') {
                if (prev?.type === 'config')
                    prev.skipLine = true;
                prev = undefined;
                field.text = normalize(field.text, !!field.pre);
                rows.push(field);
                continue;
            }
            const { value } = field;
            const desc = value.description || '';
            const mult = value.multiple ? 'Can be set multiple times' : '';
            const dmDelim = mult && (desc.includes('\n') ? '\n\n' : '\n');
            const text = normalize(desc + dmDelim + mult);
            const hint = value.hint ||
                (value.type === 'number'
                    ? 'n'
                    : value.type === 'string'
                        ? field.name
                        : undefined);
            const short = !value.short
                ? ''
                : value.type === 'boolean'
                    ? `-${value.short} `
                    : `-${value.short}<${hint}> `;
            const left = value.type === 'boolean'
                ? `${short}--${field.name}`
                : `${short}--${field.name}=<${hint}>`;
            const row = { text, left, type: 'config' };
            if (text.length > width - maxMax) {
                row.skipLine = true;
            }
            if (prev && left.length > maxMax)
                prev.skipLine = true;
            prev = row;
            const len = left.length + 4;
            if (len > maxWidth && len < maxMax) {
                maxWidth = len;
            }
            rows.push(row);
        }
        // every heading/description after the first gets indented by 2
        // extra spaces.
        for (const row of rows) {
            if (row.left) {
                // If the row is too long, don't wrap it
                // Bump the right-hand side down a line to make room
                const configIndent = indent(Math.max(headingLevel, 2));
                if (row.left.length > maxWidth - 2) {
                    ui.div({ text: row.left, padding: [0, 0, 0, configIndent] });
                    ui.div({ text: row.text, padding: [0, 0, 0, maxWidth] });
                }
                else {
                    ui.div({
                        text: row.left,
                        padding: [0, 1, 0, configIndent],
                        width: maxWidth,
                    }, { padding: [0, 0, 0, 0], text: row.text });
                }
                if (row.skipLine) {
                    ui.div({ padding: [0, 0, 0, 0], text: '' });
                }
            }
            else {
                if (isHeading(row)) {
                    const { level } = row;
                    headingLevel = level;
                    // only h1 and h2 have bottom padding
                    // h3-h6 do not
                    const b = level <= 2 ? 1 : 0;
                    ui.div({ ...row, padding: [0, 0, b, indent(level)] });
                }
                else {
                    ui.div({ ...row, padding: [0, 0, 1, indent(headingLevel + 1)] });
                }
            }
        }
        return (this.#usage = ui.toString());
    }
    /**
     * Return the configuration options as a plain object
     */
    toJSON() {
        return Object.fromEntries(Object.entries(this.#configSet).map(([field, def]) => [
            field,
            {
                type: def.type,
                ...(def.multiple ? { multiple: true } : {}),
                ...(def.delim ? { delim: def.delim } : {}),
                ...(def.short ? { short: def.short } : {}),
                ...(def.description ? { description: def.description } : {}),
                ...(def.validate ? { validate: def.validate } : {}),
                ...(def.default !== undefined ? { default: def.default } : {}),
            },
        ]));
    }
    /**
     * Custom printer for `util.inspect`
     */
    [node_util_1.inspect.custom](_, options) {
        return `Jack ${(0, node_util_1.inspect)(this.toJSON(), options)}`;
    }
}
exports.Jack = Jack;
// Unwrap and un-indent, so we can wrap description
// strings however makes them look nice in the code.
const normalize = (s, pre = false) => pre
    // prepend a ZWSP to each line so cliui doesn't strip it.
    ? s.split('\n').map(l => `\u200b${l}`).join('\n')
    : s
        // remove single line breaks, except for lists
        .replace(/([^\n])\n[ \t]*([^\n])/g, (_, $1, $2) => !/^[-*]/.test($2) ? `${$1} ${$2}` : `${$1}\n${$2}`)
        // normalize mid-line whitespace
        .replace(/([^\n])[ \t]+([^\n])/g, '$1 $2')
        // two line breaks are enough
        .replace(/\n{3,}/g, '\n\n')
        .trim();
/**
 * Main entry point. Create and return a {@link Jack} object.
 */
const jack = (options = {}) => new Jack(options);
exports.jack = jack;
//# sourceMappingURL=index.js.map
// SIG // Begin signature block
// SIG // MIIn5AYJKoZIhvcNAQcCoIIn1TCCJ9ECAQExDzANBglg
// SIG // hkgBZQMEAgEFADB3BgorBgEEAYI3AgEEoGkwZzAyBgor
// SIG // BgEEAYI3AgEeMCQCAQEEEBDgyQbOONQRoqMAEEvTUJAC
// SIG // AQACAQACAQACAQACAQAwMTANBglghkgBZQMEAgEFAAQg
// SIG // rVFcT8aki5IAUBLRFcRagKWf/Uj+5VFTwFHc4yZ6K3eg
// SIG // gg2aMIIGGDCCBACgAwIBAgITMwAAA4MUYnEL35umPQAA
// SIG // AAADgzANBgkqhkiG9w0BAQsFADB+MQswCQYDVQQGEwJV
// SIG // UzETMBEGA1UECBMKV2FzaGluZ3RvbjEQMA4GA1UEBxMH
// SIG // UmVkbW9uZDEeMBwGA1UEChMVTWljcm9zb2Z0IENvcnBv
// SIG // cmF0aW9uMSgwJgYDVQQDEx9NaWNyb3NvZnQgQ29kZSBT
// SIG // aWduaW5nIFBDQSAyMDExMB4XDTIzMDcxMzIzNDUzNloX
// SIG // DTI0MDkxNTIzNDUzNlowgYgxCzAJBgNVBAYTAlVTMRMw
// SIG // EQYDVQQIEwpXYXNoaW5ndG9uMRAwDgYDVQQHEwdSZWRt
// SIG // b25kMR4wHAYDVQQKExVNaWNyb3NvZnQgQ29ycG9yYXRp
// SIG // b24xMjAwBgNVBAMTKU1pY3Jvc29mdCAzcmQgUGFydHkg
// SIG // QXBwbGljYXRpb24gQ29tcG9uZW50MIIBIjANBgkqhkiG
// SIG // 9w0BAQEFAAOCAQ8AMIIBCgKCAQEAlZ6RXxi6ssQbUoLu
// SIG // wsUg8Lzx5c2UB0kc6aIwqPLgFQAHd8Fujs2eO7JzXVxA
// SIG // 1yizqWqcy/7OQ0BytzPoM0/Dos4MCCt8Vofm41J7qoJl
// SIG // I1vRt3RH0+n1edFpKi+XbOdDqqZBPjx/fBLFa4HL5UD3
// SIG // u8adFOmz/YuCgHsv8q5oyzgtiH9cRamcUEBldYeb1jzo
// SIG // giSktqGeOO6bBVCq0Y2pOCSEOpAqRHZWuRoZrBnR9Dxb
// SIG // +54fqFuM9OaHQAt025PPApw4G2yWSerss9TEOVJ7YJ9F
// SIG // 3QnkBGwbHIqREw+zUQtdEI9kAai6NiD8U9tS/3QufZz7
// SIG // DI2Pnw3pnwQOKRUOkwIDAQABo4IBgjCCAX4wHwYDVR0l
// SIG // BBgwFgYKKwYBBAGCN0wRAQYIKwYBBQUHAwMwHQYDVR0O
// SIG // BBYEFLbqIlKYyBFhlR+UbIclG3Vb31x0MFQGA1UdEQRN
// SIG // MEukSTBHMS0wKwYDVQQLEyRNaWNyb3NvZnQgSXJlbGFu
// SIG // ZCBPcGVyYXRpb25zIExpbWl0ZWQxFjAUBgNVBAUTDTIz
// SIG // MTUyMis1MDExNTcwHwYDVR0jBBgwFoAUSG5k5VAF04Kq
// SIG // Fzc3IrVtqMp1ApUwVAYDVR0fBE0wSzBJoEegRYZDaHR0
// SIG // cDovL3d3dy5taWNyb3NvZnQuY29tL3BraW9wcy9jcmwv
// SIG // TWljQ29kU2lnUENBMjAxMV8yMDExLTA3LTA4LmNybDBh
// SIG // BggrBgEFBQcBAQRVMFMwUQYIKwYBBQUHMAKGRWh0dHA6
// SIG // Ly93d3cubWljcm9zb2Z0LmNvbS9wa2lvcHMvY2VydHMv
// SIG // TWljQ29kU2lnUENBMjAxMV8yMDExLTA3LTA4LmNydDAM
// SIG // BgNVHRMBAf8EAjAAMA0GCSqGSIb3DQEBCwUAA4ICAQCJ
// SIG // u41n3onudflWf5dguZipzkHZ0JlADjVYe784mJX5VJmr
// SIG // HvDbRbrhTzKYbcLbmx+rWTEZRhw5jw7QOL1+jNCMOAY6
// SIG // B0oP7JBaChHiAB5TpshNEQeN5k7jTr3cGtCUj1juXunt
// SIG // Q9Acop2puL6yuximi+NR3GMAYuW/DbxpQM+ber+NUEGH
// SIG // /HuQr19f+dbkCG+BtFoVXl+ojFbLNDHIletniochj1F5
// SIG // RpXdMXJSWVeJKKNbBuGa7ln+T1XpUMUNG+UEHKmU5W1Q
// SIG // W9HrKW6FWsYeQff6INGLQ9tFf3lvnvukVdJjljyvr/Om
// SIG // Qvl1aUlShMIxc1koeIbMkmqB3Q2ASKixX1wOnxh80FcN
// SIG // RtcfvlsSfMhQ9t8BTfaQlOHASTB4ru/9bKHTQsMN99iN
// SIG // j5FP9M/GC2LRLiAw2zAcakmpj8LIdzBu3pE+5ZXROaWF
// SIG // IGcglS35OoEbt1M06gQaTm/a2NSU5KBknAaJQgCR0ldX
// SIG // mTtwoFRWbcAX2hUzf9K2xShNjKZinJHvQPR3O/MU23yL
// SIG // hzwKPQIky08+hC8FJWgT8XGyAPr1J0f3rgj+zk84SB42
// SIG // 8Au95BCZDrrElk1cWp/P3KS32Q2fVUoTGE/vvv5avrc1
// SIG // +UQft1kjY4FTDUL8PwatVilcS755GJKVhjdFOGE7+H7I
// SIG // 6qUgCthUvGTHBguMTE49qjCCB3owggVioAMCAQICCmEO
// SIG // kNIAAAAAAAMwDQYJKoZIhvcNAQELBQAwgYgxCzAJBgNV
// SIG // BAYTAlVTMRMwEQYDVQQIEwpXYXNoaW5ndG9uMRAwDgYD
// SIG // VQQHEwdSZWRtb25kMR4wHAYDVQQKExVNaWNyb3NvZnQg
// SIG // Q29ycG9yYXRpb24xMjAwBgNVBAMTKU1pY3Jvc29mdCBS
// SIG // b290IENlcnRpZmljYXRlIEF1dGhvcml0eSAyMDExMB4X
// SIG // DTExMDcwODIwNTkwOVoXDTI2MDcwODIxMDkwOVowfjEL
// SIG // MAkGA1UEBhMCVVMxEzARBgNVBAgTCldhc2hpbmd0b24x
// SIG // EDAOBgNVBAcTB1JlZG1vbmQxHjAcBgNVBAoTFU1pY3Jv
// SIG // c29mdCBDb3Jwb3JhdGlvbjEoMCYGA1UEAxMfTWljcm9z
// SIG // b2Z0IENvZGUgU2lnbmluZyBQQ0EgMjAxMTCCAiIwDQYJ
// SIG // KoZIhvcNAQEBBQADggIPADCCAgoCggIBAKvw+nIQHC6t
// SIG // 2G6qghBNNLrytlghn0IbKmvpWlCquAY4GgRJun/DDB7d
// SIG // N2vGEtgL8DjCmQawyDnVARQxQtOJDXlkh36UYCRsr55J
// SIG // nOloXtLfm1OyCizDr9mpK656Ca/XllnKYBoF6WZ26DJS
// SIG // JhIv56sIUM+zRLdd2MQuA3WraPPLbfM6XKEW9Ea64Dhk
// SIG // rG5kNXimoGMPLdNAk/jj3gcN1Vx5pUkp5w2+oBN3vpQ9
// SIG // 7/vjK1oQH01WKKJ6cuASOrdJXtjt7UORg9l7snuGG9k+
// SIG // sYxd6IlPhBryoS9Z5JA7La4zWMW3Pv4y07MDPbGyr5I4
// SIG // ftKdgCz1TlaRITUlwzluZH9TupwPrRkjhMv0ugOGjfdf
// SIG // 8NBSv4yUh7zAIXQlXxgotswnKDglmDlKNs98sZKuHCOn
// SIG // qWbsYR9q4ShJnV+I4iVd0yFLPlLEtVc/JAPw0XpbL9Uj
// SIG // 43BdD1FGd7P4AOG8rAKCX9vAFbO9G9RVS+c5oQ/pI0m8
// SIG // GLhEfEXkwcNyeuBy5yTfv0aZxe/CHFfbg43sTUkwp6uO
// SIG // 3+xbn6/83bBm4sGXgXvt1u1L50kppxMopqd9Z4DmimJ4
// SIG // X7IvhNdXnFy/dygo8e1twyiPLI9AN0/B4YVEicQJTMXU
// SIG // pUMvdJX3bvh4IFgsE11glZo+TzOE2rCIF96eTvSWsLxG
// SIG // oGyY0uDWiIwLAgMBAAGjggHtMIIB6TAQBgkrBgEEAYI3
// SIG // FQEEAwIBADAdBgNVHQ4EFgQUSG5k5VAF04KqFzc3IrVt
// SIG // qMp1ApUwGQYJKwYBBAGCNxQCBAweCgBTAHUAYgBDAEEw
// SIG // CwYDVR0PBAQDAgGGMA8GA1UdEwEB/wQFMAMBAf8wHwYD
// SIG // VR0jBBgwFoAUci06AjGQQ7kUBU7h6qfHMdEjiTQwWgYD
// SIG // VR0fBFMwUTBPoE2gS4ZJaHR0cDovL2NybC5taWNyb3Nv
// SIG // ZnQuY29tL3BraS9jcmwvcHJvZHVjdHMvTWljUm9vQ2Vy
// SIG // QXV0MjAxMV8yMDExXzAzXzIyLmNybDBeBggrBgEFBQcB
// SIG // AQRSMFAwTgYIKwYBBQUHMAKGQmh0dHA6Ly93d3cubWlj
// SIG // cm9zb2Z0LmNvbS9wa2kvY2VydHMvTWljUm9vQ2VyQXV0
// SIG // MjAxMV8yMDExXzAzXzIyLmNydDCBnwYDVR0gBIGXMIGU
// SIG // MIGRBgkrBgEEAYI3LgMwgYMwPwYIKwYBBQUHAgEWM2h0
// SIG // dHA6Ly93d3cubWljcm9zb2Z0LmNvbS9wa2lvcHMvZG9j
// SIG // cy9wcmltYXJ5Y3BzLmh0bTBABggrBgEFBQcCAjA0HjIg
// SIG // HQBMAGUAZwBhAGwAXwBwAG8AbABpAGMAeQBfAHMAdABh
// SIG // AHQAZQBtAGUAbgB0AC4gHTANBgkqhkiG9w0BAQsFAAOC
// SIG // AgEAZ/KGpZjgVHkaLtPYdGcimwuWEeFjkplCln3SeQyQ
// SIG // wWVfLiw++MNy0W2D/r4/6ArKO79HqaPzadtjvyI1pZdd
// SIG // ZYSQfYtGUFXYDJJ80hpLHPM8QotS0LD9a+M+By4pm+Y9
// SIG // G6XUtR13lDni6WTJRD14eiPzE32mkHSDjfTLJgJGKsKK
// SIG // ELukqQUMm+1o+mgulaAqPyprWEljHwlpblqYluSD9MCP
// SIG // 80Yr3vw70L01724lruWvJ+3Q3fMOr5kol5hNDj0L8giJ
// SIG // 1h/DMhji8MUtzluetEk5CsYKwsatruWy2dsViFFFWDgy
// SIG // cScaf7H0J/jeLDogaZiyWYlobm+nt3TDQAUGpgEqKD6C
// SIG // PxNNZgvAs0314Y9/HG8VfUWnduVAKmWjw11SYobDHWM2
// SIG // l4bf2vP48hahmifhzaWX0O5dY0HjWwechz4GdwbRBrF1
// SIG // HxS+YWG18NzGGwS+30HHDiju3mUv7Jf2oVyW2ADWoUa9
// SIG // WfOXpQlLSBCZgB/QACnFsZulP0V3HjXG0qKin3p6IvpI
// SIG // lR+r+0cjgPWe+L9rt0uX4ut1eBrs6jeZeRhL/9azI2h1
// SIG // 5q/6/IvrC4DqaTuv/DDtBEyO3991bWORPdGdVk5Pv4BX
// SIG // IqF4ETIheu9BCrE/+6jMpF3BoYibV3FWTkhFwELJm3Zb
// SIG // CoBIa/15n8G9bW1qyVJzEw16UM0xghmiMIIZngIBATCB
// SIG // lTB+MQswCQYDVQQGEwJVUzETMBEGA1UECBMKV2FzaGlu
// SIG // Z3RvbjEQMA4GA1UEBxMHUmVkbW9uZDEeMBwGA1UEChMV
// SIG // TWljcm9zb2Z0IENvcnBvcmF0aW9uMSgwJgYDVQQDEx9N
// SIG // aWNyb3NvZnQgQ29kZSBTaWduaW5nIFBDQSAyMDExAhMz
// SIG // AAADgxRicQvfm6Y9AAAAAAODMA0GCWCGSAFlAwQCAQUA
// SIG // oIGuMBkGCSqGSIb3DQEJAzEMBgorBgEEAYI3AgEEMBwG
// SIG // CisGAQQBgjcCAQsxDjAMBgorBgEEAYI3AgEVMC8GCSqG
// SIG // SIb3DQEJBDEiBCBCK4WIhqmK2R1ZYTJhYFE+9Xwd4mBA
// SIG // 6ZtDGlfXoQiW3jBCBgorBgEEAYI3AgEMMTQwMqAUgBIA
// SIG // TQBpAGMAcgBvAHMAbwBmAHShGoAYaHR0cDovL3d3dy5t
// SIG // aWNyb3NvZnQuY29tMA0GCSqGSIb3DQEBAQUABIIBAJNE
// SIG // 7caEKiz7PFCrMffrx21A8ldy6FravFPJV0Ut9t77MhMD
// SIG // Kga1kiuG/ywuKMQqmLDBdPUl+v6Dl0xkR/geT54nn0j9
// SIG // W9O5Y1kKSKhI8MTFwtzm6pjs25SX+nWfE7zxVg4zeJ4h
// SIG // oUgJJp6WYsAyDHqyKs8VjI+6rckfqS9MPQSDQIy765Df
// SIG // YmSsTA2F5Pu6VNVWPyt52SO7tzN6RLVmYWIhs3F5mkdC
// SIG // QR52VMc6pl7NDqC7I9nF+07XqFjIBoGWB5NIppO/wi3W
// SIG // 5+dnncoOvaG0ai3X1M1bwZdlRZg+E/H/zVUUA11zjjzO
// SIG // mdfN2Kwx922SdNOUi19mlN7hSiN/WBqhghcsMIIXKAYK
// SIG // KwYBBAGCNwMDATGCFxgwghcUBgkqhkiG9w0BBwKgghcF
// SIG // MIIXAQIBAzEPMA0GCWCGSAFlAwQCAQUAMIIBWQYLKoZI
// SIG // hvcNAQkQAQSgggFIBIIBRDCCAUACAQEGCisGAQQBhFkK
// SIG // AwEwMTANBglghkgBZQMEAgEFAAQg8EUTerVXIn+7Zk5R
// SIG // X4XwZt38dwW/D5iJI0yIe+vDdDkCBmVCvZzWvxgTMjAy
// SIG // MzExMTUwMDExMjQuMzk1WjAEgAIB9KCB2KSB1TCB0jEL
// SIG // MAkGA1UEBhMCVVMxEzARBgNVBAgTCldhc2hpbmd0b24x
// SIG // EDAOBgNVBAcTB1JlZG1vbmQxHjAcBgNVBAoTFU1pY3Jv
// SIG // c29mdCBDb3Jwb3JhdGlvbjEtMCsGA1UECxMkTWljcm9z
// SIG // b2Z0IElyZWxhbmQgT3BlcmF0aW9ucyBMaW1pdGVkMSYw
// SIG // JAYDVQQLEx1UaGFsZXMgVFNTIEVTTjozQkQ0LTRCODAt
// SIG // NjlDMzElMCMGA1UEAxMcTWljcm9zb2Z0IFRpbWUtU3Rh
// SIG // bXAgU2VydmljZaCCEXswggcnMIIFD6ADAgECAhMzAAAB
// SIG // 5Y9qwPM9tAujAAEAAAHlMA0GCSqGSIb3DQEBCwUAMHwx
// SIG // CzAJBgNVBAYTAlVTMRMwEQYDVQQIEwpXYXNoaW5ndG9u
// SIG // MRAwDgYDVQQHEwdSZWRtb25kMR4wHAYDVQQKExVNaWNy
// SIG // b3NvZnQgQ29ycG9yYXRpb24xJjAkBgNVBAMTHU1pY3Jv
// SIG // c29mdCBUaW1lLVN0YW1wIFBDQSAyMDEwMB4XDTIzMTAx
// SIG // MjE5MDczNVoXDTI1MDExMDE5MDczNVowgdIxCzAJBgNV
// SIG // BAYTAlVTMRMwEQYDVQQIEwpXYXNoaW5ndG9uMRAwDgYD
// SIG // VQQHEwdSZWRtb25kMR4wHAYDVQQKExVNaWNyb3NvZnQg
// SIG // Q29ycG9yYXRpb24xLTArBgNVBAsTJE1pY3Jvc29mdCBJ
// SIG // cmVsYW5kIE9wZXJhdGlvbnMgTGltaXRlZDEmMCQGA1UE
// SIG // CxMdVGhhbGVzIFRTUyBFU046M0JENC00QjgwLTY5QzMx
// SIG // JTAjBgNVBAMTHE1pY3Jvc29mdCBUaW1lLVN0YW1wIFNl
// SIG // cnZpY2UwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIK
// SIG // AoICAQCpe+A62rtjuiy6yTtx8k7zvWl2ov/3jcj+TC1m
// SIG // a5lBjTiTD8DCNPFfcwX0TzXLnK3iGEsiR45DCFBprodK
// SIG // z1ef9vlAixqzdT++5/X6v5nc1zDdRc6mjx3ShJSp3iUP
// SIG // EenD+Ha7thspprda6xnDXvNNAnA+nfzXaKJppHdfelaj
// SIG // rY2RQNV1rvhrBQXlh4ns/z5ZanDP3lp7ZEDLNJStM5gn
// SIG // x/gbu4tYfhQ0UfBe1s1K/+zN44VXT6QH6ts2AgPGVSzY
// SIG // BIs2PrxZoMfsw7rlPxgoQyu5JQ3AsPv4FaBLkjpeXJUL
// SIG // MnVkIySV+2dslftSguhtSVaqT93aSjwD/+LnTaqUeRyH
// SIG // m/E2tSX40VM0r96ko3ucvUWE/wI1jWEO4LHs7g1jP/HG
// SIG // ddZHKNSb1MjkPMfyQ5DBakkcI9b/pnOiyipY//3Vghvx
// SIG // 8PaaXZViV+qbA3rELkEexVe3gqlf5X2o6C6Tzcf/cxdX
// SIG // b/MlwXc5liT3gontl2kJ6wCg6pRt817sfbTUJs9i/ek3
// SIG // cZyDtjhpmMQQAGQFqCm5rWCPgos+AmMjtBZuWd0+NGuX
// SIG // eyibn7Regk6HHHP1Kf46RX0IrS343e9XEvnCwnqEPqtJ
// SIG // 9CAC71fmnGxDaLkjq47/0LWOBSIx5SOc3ScyZxrJFSea
// SIG // M4Y4tGEbHL9VsCRQLssgjELy3Zj3XQIDAQABo4IBSTCC
// SIG // AUUwHQYDVR0OBBYEFN//n4e7TXMxInxF5QkIBTl4DIeq
// SIG // MB8GA1UdIwQYMBaAFJ+nFV0AXmJdg/Tl0mWnG1M1Gely
// SIG // MF8GA1UdHwRYMFYwVKBSoFCGTmh0dHA6Ly93d3cubWlj
// SIG // cm9zb2Z0LmNvbS9wa2lvcHMvY3JsL01pY3Jvc29mdCUy
// SIG // MFRpbWUtU3RhbXAlMjBQQ0ElMjAyMDEwKDEpLmNybDBs
// SIG // BggrBgEFBQcBAQRgMF4wXAYIKwYBBQUHMAKGUGh0dHA6
// SIG // Ly93d3cubWljcm9zb2Z0LmNvbS9wa2lvcHMvY2VydHMv
// SIG // TWljcm9zb2Z0JTIwVGltZS1TdGFtcCUyMFBDQSUyMDIw
// SIG // MTAoMSkuY3J0MAwGA1UdEwEB/wQCMAAwFgYDVR0lAQH/
// SIG // BAwwCgYIKwYBBQUHAwgwDgYDVR0PAQH/BAQDAgeAMA0G
// SIG // CSqGSIb3DQEBCwUAA4ICAQAz+sIThYw9WnfBpBCfaCwb
// SIG // r3453TMhkPUeB4ASkpT7d6WtF1S3IpqyZQ5yhoBQYlsC
// SIG // OlzoMPNoXaJQ4jAwSy1kTEyR1lXlGNYFOFwfDjiMQXPf
// SIG // 0PN829XNEVhLqYAuPCPm/tsdlTYBiVLECMj0dj4l0IU+
// SIG // T8nqzIGoPTkqHUIxcKTXRoq52tq6VdtxFMBXjuft6El+
// SIG // CXgjWb4MlDsyqcjL6lWrm6PhpX/6bH1ubSHDI2VbdHpb
// SIG // MH6tKiTUIKGIqW2k77+8ZosVCRk24sWIn08AIrz3CjXX
// SIG // orGZrbbOzh2wDO/eWbyi0hKl4kVIw2Gcnh8gMrDBAC2y
// SIG // IXV4BxIetCqGcs5QV891cRIqxO54bnDcDNrVYjpcCOxJ
// SIG // HlOYbnXLZ1whueSbjMP8G+3O9USopmQPyl5VqZgb5CZA
// SIG // dAWREvDghg3fs2P0/QZ06fLIt+k6pfOFX6WHvYh5suz6
// SIG // qsajBdgp+KtmtJhDJ6Qa7gxhP4EfXPElSdp7ZAEcuUn5
// SIG // brifzAetckb09ZlMd5cqaTttnj4wY58KBL1cWw409Y4X
// SIG // TDXXrzrg3iRs0SyvRzZkwwvk3WUJY/lTICJvGXhCETRd
// SIG // KGr4hfkGXFGS1s1m2Kusg6JPBGShYkUeaLQaBi72mBac
// SIG // QWVBPJpyyrg5WKG468Ye5Z8K8Vf3zMtBfX0qNicRZrS4
// SIG // LTCCB3EwggVZoAMCAQICEzMAAAAVxedrngKbSZkAAAAA
// SIG // ABUwDQYJKoZIhvcNAQELBQAwgYgxCzAJBgNVBAYTAlVT
// SIG // MRMwEQYDVQQIEwpXYXNoaW5ndG9uMRAwDgYDVQQHEwdS
// SIG // ZWRtb25kMR4wHAYDVQQKExVNaWNyb3NvZnQgQ29ycG9y
// SIG // YXRpb24xMjAwBgNVBAMTKU1pY3Jvc29mdCBSb290IENl
// SIG // cnRpZmljYXRlIEF1dGhvcml0eSAyMDEwMB4XDTIxMDkz
// SIG // MDE4MjIyNVoXDTMwMDkzMDE4MzIyNVowfDELMAkGA1UE
// SIG // BhMCVVMxEzARBgNVBAgTCldhc2hpbmd0b24xEDAOBgNV
// SIG // BAcTB1JlZG1vbmQxHjAcBgNVBAoTFU1pY3Jvc29mdCBD
// SIG // b3Jwb3JhdGlvbjEmMCQGA1UEAxMdTWljcm9zb2Z0IFRp
// SIG // bWUtU3RhbXAgUENBIDIwMTAwggIiMA0GCSqGSIb3DQEB
// SIG // AQUAA4ICDwAwggIKAoICAQDk4aZM57RyIQt5osvXJHm9
// SIG // DtWC0/3unAcH0qlsTnXIyjVX9gF/bErg4r25PhdgM/9c
// SIG // T8dm95VTcVrifkpa/rg2Z4VGIwy1jRPPdzLAEBjoYH1q
// SIG // UoNEt6aORmsHFPPFdvWGUNzBRMhxXFExN6AKOG6N7dcP
// SIG // 2CZTfDlhAnrEqv1yaa8dq6z2Nr41JmTamDu6GnszrYBb
// SIG // fowQHJ1S/rboYiXcag/PXfT+jlPP1uyFVk3v3byNpOOR
// SIG // j7I5LFGc6XBpDco2LXCOMcg1KL3jtIckw+DJj361VI/c
// SIG // +gVVmG1oO5pGve2krnopN6zL64NF50ZuyjLVwIYwXE8s
// SIG // 4mKyzbnijYjklqwBSru+cakXW2dg3viSkR4dPf0gz3N9
// SIG // QZpGdc3EXzTdEonW/aUgfX782Z5F37ZyL9t9X4C626p+
// SIG // Nuw2TPYrbqgSUei/BQOj0XOmTTd0lBw0gg/wEPK3Rxjt
// SIG // p+iZfD9M269ewvPV2HM9Q07BMzlMjgK8QmguEOqEUUbi
// SIG // 0b1qGFphAXPKZ6Je1yh2AuIzGHLXpyDwwvoSCtdjbwzJ
// SIG // NmSLW6CmgyFdXzB0kZSU2LlQ+QuJYfM2BjUYhEfb3BvR
// SIG // /bLUHMVr9lxSUV0S2yW6r1AFemzFER1y7435UsSFF5PA
// SIG // PBXbGjfHCBUYP3irRbb1Hode2o+eFnJpxq57t7c+auIu
// SIG // rQIDAQABo4IB3TCCAdkwEgYJKwYBBAGCNxUBBAUCAwEA
// SIG // ATAjBgkrBgEEAYI3FQIEFgQUKqdS/mTEmr6CkTxGNSnP
// SIG // EP8vBO4wHQYDVR0OBBYEFJ+nFV0AXmJdg/Tl0mWnG1M1
// SIG // GelyMFwGA1UdIARVMFMwUQYMKwYBBAGCN0yDfQEBMEEw
// SIG // PwYIKwYBBQUHAgEWM2h0dHA6Ly93d3cubWljcm9zb2Z0
// SIG // LmNvbS9wa2lvcHMvRG9jcy9SZXBvc2l0b3J5Lmh0bTAT
// SIG // BgNVHSUEDDAKBggrBgEFBQcDCDAZBgkrBgEEAYI3FAIE
// SIG // DB4KAFMAdQBiAEMAQTALBgNVHQ8EBAMCAYYwDwYDVR0T
// SIG // AQH/BAUwAwEB/zAfBgNVHSMEGDAWgBTV9lbLj+iiXGJo
// SIG // 0T2UkFvXzpoYxDBWBgNVHR8ETzBNMEugSaBHhkVodHRw
// SIG // Oi8vY3JsLm1pY3Jvc29mdC5jb20vcGtpL2NybC9wcm9k
// SIG // dWN0cy9NaWNSb29DZXJBdXRfMjAxMC0wNi0yMy5jcmww
// SIG // WgYIKwYBBQUHAQEETjBMMEoGCCsGAQUFBzAChj5odHRw
// SIG // Oi8vd3d3Lm1pY3Jvc29mdC5jb20vcGtpL2NlcnRzL01p
// SIG // Y1Jvb0NlckF1dF8yMDEwLTA2LTIzLmNydDANBgkqhkiG
// SIG // 9w0BAQsFAAOCAgEAnVV9/Cqt4SwfZwExJFvhnnJL/Klv
// SIG // 6lwUtj5OR2R4sQaTlz0xM7U518JxNj/aZGx80HU5bbsP
// SIG // MeTCj/ts0aGUGCLu6WZnOlNN3Zi6th542DYunKmCVgAD
// SIG // sAW+iehp4LoJ7nvfam++Kctu2D9IdQHZGN5tggz1bSNU
// SIG // 5HhTdSRXud2f8449xvNo32X2pFaq95W2KFUn0CS9QKC/
// SIG // GbYSEhFdPSfgQJY4rPf5KYnDvBewVIVCs/wMnosZiefw
// SIG // C2qBwoEZQhlSdYo2wh3DYXMuLGt7bj8sCXgU6ZGyqVvf
// SIG // SaN0DLzskYDSPeZKPmY7T7uG+jIa2Zb0j/aRAfbOxnT9
// SIG // 9kxybxCrdTDFNLB62FD+CljdQDzHVG2dY3RILLFORy3B
// SIG // FARxv2T5JL5zbcqOCb2zAVdJVGTZc9d/HltEAY5aGZFr
// SIG // DZ+kKNxnGSgkujhLmm77IVRrakURR6nxt67I6IleT53S
// SIG // 0Ex2tVdUCbFpAUR+fKFhbHP+CrvsQWY9af3LwUFJfn6T
// SIG // vsv4O+S3Fb+0zj6lMVGEvL8CwYKiexcdFYmNcP7ntdAo
// SIG // GokLjzbaukz5m/8K6TT4JDVnK+ANuOaMmdbhIurwJ0I9
// SIG // JZTmdHRbatGePu1+oDEzfbzL6Xu/OHBE0ZDxyKs6ijoI
// SIG // Yn/ZcGNTTY3ugm2lBRDBcQZqELQdVTNYs6FwZvKhggLX
// SIG // MIICQAIBATCCAQChgdikgdUwgdIxCzAJBgNVBAYTAlVT
// SIG // MRMwEQYDVQQIEwpXYXNoaW5ndG9uMRAwDgYDVQQHEwdS
// SIG // ZWRtb25kMR4wHAYDVQQKExVNaWNyb3NvZnQgQ29ycG9y
// SIG // YXRpb24xLTArBgNVBAsTJE1pY3Jvc29mdCBJcmVsYW5k
// SIG // IE9wZXJhdGlvbnMgTGltaXRlZDEmMCQGA1UECxMdVGhh
// SIG // bGVzIFRTUyBFU046M0JENC00QjgwLTY5QzMxJTAjBgNV
// SIG // BAMTHE1pY3Jvc29mdCBUaW1lLVN0YW1wIFNlcnZpY2Wi
// SIG // IwoBATAHBgUrDgMCGgMVAPeNohrmBa7BOMM1g3fORKTO
// SIG // kYsKoIGDMIGApH4wfDELMAkGA1UEBhMCVVMxEzARBgNV
// SIG // BAgTCldhc2hpbmd0b24xEDAOBgNVBAcTB1JlZG1vbmQx
// SIG // HjAcBgNVBAoTFU1pY3Jvc29mdCBDb3Jwb3JhdGlvbjEm
// SIG // MCQGA1UEAxMdTWljcm9zb2Z0IFRpbWUtU3RhbXAgUENB
// SIG // IDIwMTAwDQYJKoZIhvcNAQEFBQACBQDo/l9aMCIYDzIw
// SIG // MjMxMTE1MDUwNDI2WhgPMjAyMzExMTYwNTA0MjZaMHcw
// SIG // PQYKKwYBBAGEWQoEATEvMC0wCgIFAOj+X1oCAQAwCgIB
// SIG // AAICAWkCAf8wBwIBAAICEXgwCgIFAOj/sNoCAQAwNgYK
// SIG // KwYBBAGEWQoEAjEoMCYwDAYKKwYBBAGEWQoDAqAKMAgC
// SIG // AQACAwehIKEKMAgCAQACAwGGoDANBgkqhkiG9w0BAQUF
// SIG // AAOBgQBxn+X5u963KZWMfAKENCbQmv5ak+usd5B8/SEd
// SIG // TvfRdgGxfmrEmL/sNghuVvfALXxYBrYVqjSSH2rtx+EP
// SIG // 9vsuPJsOW2VuXy5fHyfRva6D9biuGvRdutzeHxgo2gom
// SIG // 0WJzmUqen2YoLgc3jdrVBn1o/L3AG1+ElRI0W8FPOdT9
// SIG // NjGCBA0wggQJAgEBMIGTMHwxCzAJBgNVBAYTAlVTMRMw
// SIG // EQYDVQQIEwpXYXNoaW5ndG9uMRAwDgYDVQQHEwdSZWRt
// SIG // b25kMR4wHAYDVQQKExVNaWNyb3NvZnQgQ29ycG9yYXRp
// SIG // b24xJjAkBgNVBAMTHU1pY3Jvc29mdCBUaW1lLVN0YW1w
// SIG // IFBDQSAyMDEwAhMzAAAB5Y9qwPM9tAujAAEAAAHlMA0G
// SIG // CWCGSAFlAwQCAQUAoIIBSjAaBgkqhkiG9w0BCQMxDQYL
// SIG // KoZIhvcNAQkQAQQwLwYJKoZIhvcNAQkEMSIEIPi0lNik
// SIG // QsnFBlfPmnhnhYt+RkpqJxzCu0EBOcwBf4NBMIH6Bgsq
// SIG // hkiG9w0BCRACLzGB6jCB5zCB5DCBvQQgFanT//6o8RhY
// SIG // XtmG6BF3m/CP6QKH9NQsIW8VB/VOve0wgZgwgYCkfjB8
// SIG // MQswCQYDVQQGEwJVUzETMBEGA1UECBMKV2FzaGluZ3Rv
// SIG // bjEQMA4GA1UEBxMHUmVkbW9uZDEeMBwGA1UEChMVTWlj
// SIG // cm9zb2Z0IENvcnBvcmF0aW9uMSYwJAYDVQQDEx1NaWNy
// SIG // b3NvZnQgVGltZS1TdGFtcCBQQ0EgMjAxMAITMwAAAeWP
// SIG // asDzPbQLowABAAAB5TAiBCB3LIZPtINMMiJnmw07E8DQ
// SIG // 7UbM3PGwRRHDG5hItaXJgzANBgkqhkiG9w0BAQsFAASC
// SIG // AgCL2KoBNd2qYVuntwYKf+Zk76i8i44GFTXhrF/YxMzi
// SIG // hQoj6k09UbVWuuD8rvZC0YMdhG1rMVoTgpex4ZgpT3YA
// SIG // dgQIOt/pcRUZdC3Zb4Tc4X1mWuG4gs46JivCfVQC62jq
// SIG // 6X+5wEqbe1QwS6JB/KQz9Z93MB5bpgFA/UwPd40YAcfA
// SIG // 7UZmkMAEndnk0e+uegVP5wXJydTIqALKEIlzeBi9te2M
// SIG // IWxkMW9DdpArfFeXqpkXUeq+NZ5R/wclfESttl2xmo2v
// SIG // j5x6tamh4fCSC6B0oxPdqb235iW/sfTwqquZMQOJISUY
// SIG // 7j46S+HZgSoC3wvqqJ9g8iHhVo+gII1nROayl+YwMsMX
// SIG // QZp9NqeR+cIekBPeyHBm/yG85jh4oY1ntCTAXDasAGyp
// SIG // dJxUXTotbIBh6ZVP9e/hC5N0PQHd94duakI4vBcysMQe
// SIG // 8C8VnqW8NON/SbGGcMFGwXw2lT3SHBj8+G2d4uos67AL
// SIG // 1+4Z482EhMAIosS/76stOpIy5HQoCp5g9O2JhOUKulk2
// SIG // Op8JWRqx8UMiBaEa6lQG9Rng5CLrYXbkbQsQUPcbqyOt
// SIG // MyntvccoywACwx98GB1crMDxQjiBUf4TH5Fqw0dLMxsB
// SIG // /75JhLuATwJjmvKt9xSjjyN2p72iiIU6V8H2/3N8RD5t
// SIG // hIXx6rnemu/xQ6xPyETlR3axJg==
// SIG // End signature block
